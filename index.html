
<!DOCTYPE HTML>
<html>
<head>
	<meta http-equiv="Content-Type" content="text/html" charset="UTF-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
	<meta charset="utf-8">
	<title>hjinu</title>

	<meta name="author" content="hjinu">
	
	<meta name="description" content="14 Jul 2014 Naver 오픈소스 Arcus 정리 네이버에서 오픈 소스 프로젝트로 공개한 Arcus를 공부하면서 알게 된 Arcus의 특징 몇가지를 정리함. - Zookeeper 사용 서버를 관리하기 위해서 Zookeeper를 사용. 서버의 추가나 장애 발생 &hellip;">

	<meta name="HandheldFriendly" content="True" />
	<meta name="MobileOptimized" content="320" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />

	<link href="/atom.xml" rel="alternate" title="hjinu" type="application/atom+xml">
	<link rel="canonical" href="">
	<link href="/favicon.png" rel="shortcut icon">
	<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic|Open+Sans:700,400" />
	<link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->
</head>

<body class="home-template">
  <header id="site-head">
  <div class="vertical">
    <div id="site-head-content" class="inner">
      <h1 class="blog-title"><a class="no-rollover" href="/">hjinu</a></h1>
      <h2 class="blog-description">I love all I do</h2>
    </div>
  </div>
</header>
  <main class="content" role="main">
    



    <article class="post">
	
		
	
	<header class="post-header">
		<span class="post-meta">14 Jul 2014</span>
		<h2 class="post-title">
			
			<a href="/blog/2014/07/14/naver-ec98a4ed9488ec868cec8aa4-ed9484eba19ceca09ded8ab8-arcus-eca095eba6ac/">
			
				Naver 오픈소스 Arcus 정리</a>
		</h2>
	</header>
	<section class="post-excerpt">
		<p>네이버에서 오픈 소스 프로젝트로 공개한 Arcus를 공부하면서 알게 된 Arcus의 특징 몇가지를 정리함.</p>

<h5 id="zookeeper-">- Zookeeper 사용</h5>

<ul>
  <li>
    <p>서버를 관리하기 위해서 Zookeeper를 사용. 서버의 추가나 장애 발생 시 대응에 용이.</p>
  </li>
  <li>
    <p>서버가 켜질 때엔 Zookeeper에 IP:PORT로 검색해서 자신이 서비스되어야할 코드를 찾고 이 코드에 ephemeral node를 생성. ephemeral node는 세션이 유효한 동안만 살아있기 때문에 만약에 서버에 문제가 생겨서 세션이 종료되면 node가 사라지고 이를 바탕으로 캐시 데이터의 재분배가 가능.</p>
  </li>
</ul>

<h5 id="eager-item-expiration">- Eager Item Expiration</h5>

<ul>
  <li>
    <p>기존의 메모리 관리 방식에서는 LRU가 실행되면 Tail에 위치한 N개의 item만 검사한다. 이 방식에 문제점이 있는데 이는 memcached의 expired된 아이템을 삭제하는 방식과 관련되어 있음.</p>
  </li>
  <li>
    <p>memcached는 item의 expired_time이 지나면 바로 메모리에서 지우는 것이 아니라 expired된 아이템에 get 요청을 했을 때 ‘Item이 없다’ 라고 응답하고 item을 지우기 때문.</p>
  </li>
  <li>
    <p>그래서 Tail에 위치한 N개의 item만을 검사하면 이미 expired된 item이 있음에도 불구하고 다른 item이 evict될 수 있다. 또한 expired된 item이 메모리에 계속 올라가 있기 때문에 메모리 사용량을 확인하는 데에도 어려움.</p>
  </li>
  <li>
    <p>Eager Item Expiration은 이 문제를 해결하기 위해서 Tail에 위치한 N개의 item 이 외에도 <strong>LRU 리스트를 점진적으로 traverse하면서 N개의 item을 검사</strong>한다.</p>
  </li>
</ul>

<h5 id="collection-">- Collection 지원</h5>

<ul>
  <li>네이버 서비스 중에서 feed를 제공하는 서비스의 요구사항에 맞춘 데이터 구조</li>
</ul>

	</section>
</article>


    <article class="post">
	
	<header class="post-header">
		<span class="post-meta">03 Jul 2014</span>
		<h2 class="post-title">
			
			<a href="/blog/2014/07/03/githubec9790ec849c-gem-ec84a4ecb998ed9598eab8b0/">
			
				Github에서 Gem 설치하기</a>
		</h2>
	</header>
	<section class="post-excerpt">
		<p>dalli 소스를 분석하던 도중 소스를 약간 수정하려고 fork를 해왔는데 이 fork한 gem을 어떻게 설치해야 하는지 몰라서 당황했음.</p>

<p>방법을 좀 찾아보니 git을 클론해와서 gem을 다시 빌드, 설치하면 되는데 정리해보겠음.</p>

<ol>
  <li>
    <p>git을 클론</p>

    <p>git clone https://github.com/hjinu/dalli.git</p>
  </li>
  <li>
    <p>gem을 빌드</p>

    <p>cd dalli &amp;&amp; gem bulid dalli.gemspec</p>
  </li>
  <li>
    <p>gem을 인스톨</p>

    <p>gem install dalli-2.7.2.gem</p>
  </li>
</ol>

<p>출처는 요기 : http://stackoverflow.com/questions/16365146/install-ruby-gem-globally-from-github-repository</p>

	</section>
</article>


    <article class="post">
	
	<header class="post-header">
		<span class="post-meta">03 Jul 2014</span>
		<h2 class="post-title">
			
			<a href="/blog/2014/07/03/vi-eab280ec8389-ebb08f-ecb998ed9998/">
			
				Vi 검색 및 치환</a>
		</h2>
	</header>
	<section class="post-excerpt">
		<p>애초에 치환이라는 걸 잘 안쓰다가 sublime 쓰다가 Vi로 다시 넘어보니까 치환이 너무 필요했음…</p>

<p>찾아보니까 너무 쉽고 편함. 아니 사실 쉽진않아.. 어쨌든 정리하면.</p>

<h3 id="section"><strong>검색</strong></h3>

<p>앞으로 검색 	: /KEYWORD</p>

<p>뒤로 검색     	: ?KEYWORD</p>

<p>다음 검색 결과 	: n</p>

<p>이전 검색 결과 	: N</p>

<h3 id="section-1"><strong>치환</strong></h3>

<p>현재 라인에서 첫 번째 결과만 치환   :  s/OLD/NEW</p>

<p>현재 라인에서 모든 결과 치환        :  s/OLD/NEW/g</p>

<p>라인에서 라인 사이를 모두 치환      :  #,*s/OLD/NEW/g</p>

<p>파일 내의 모든 결과를 치환          :  %s/OLD/NEW/g</p>

<p>출처는 요기 : http://www.felixgers.de/teaching/emacs/vi_search_replace.html</p>

	</section>
</article>


    <article class="post">
	
	<header class="post-header">
		<span class="post-meta">02 Jul 2014</span>
		<h2 class="post-title">
			
			<a href="/blog/2014/07/02/ed858cec8aa4ed8ab8-eca3bceb8f84-eab09cebb09ctddec9790-eb8c80ed95b4ec849c/">
			
				테스트 주도 개발(TDD)에 대해서</a>
		</h2>
	</header>
	<section class="post-excerpt">
		<p>예전에 Rails Tutorial 할때 테스트를 계속 짜면서 이걸 왜 하나 싶었는데 알고보니까 TDD의 장점은 과감한 리팩토링이 가능한 거였다.</p>

<p>튜토리얼은 따라 하는 거라서 리팩토링을 할 일이 없어서 별로 필요성을 못 느꼈었는데 새삼 대단한 걸 느끼고 계속 테스트를 작성하는 버릇을 들여야겠다고 생각함. 유닛 단위의 테스트가 크게 의미있다기 보다는 그 테스트들이 점점 쌓여서 소프트웨어의 무결성을 보장한다는 점이 참 대단. 젤리버스에서 일 할 때도 추후에 수정한 부분이 예상치 못한 부분을 건드려서 버그를 만드는 경우가 많았는데 이런 점을 대부분 막을 수 있을 것 같다. </p>

<p>git 으로 버전관리 + 테스트 작성으로 맘에 안드는 부분이 있으면 그냥 가벼운 마음으로 브랜치해서 테스트 통과하는 지만 보면서 과감하게 들어엎는 리팩토링을 할 수 있을 거라고 생각하니 뭔가 두근두근</p>

	</section>
</article>


    <article class="post">
	
	<header class="post-header">
		<span class="post-meta">27 Jun 2014</span>
		<h2 class="post-title">
			
			<a href="/blog/2014/06/27/eba6aceb8885ec8aa4ec9790ec849c-eba3a8ed8ab8-eab68ced959c-ec9786ec9db4-ed8ca8ed82a4eca780-ec84a4ecb998ed9598eb8a94-ebb0a9ebb295/">
			
				리눅스에서 루트 권한 없이 패키지 설치하는 방법</a>
		</h2>
	</header>
	<section class="post-excerpt">
		<p>리눅스 초보에서 개발 환경 세팅은 언제나 골치 아프다. 특히 루트 권한을 얻지 못할 때에는 더 심한데 그 이유는</p>

<ol>
  <li>
    <p>패키지를 쉽게 설치할 수 있는 yum 같은 패키지 관리자가 루트 권한을 자주 요청하기 때문이고</p>
  </li>
  <li>
    <p>그래서 직접 다운로드 받아서 설치하려고 해도 기본적으로 패키지가 설치되는 경로가 루트 권한을 필요로 하기 때문이다.</p>
  </li>
</ol>

<p>그래서 루트 권한이 없을 때에는 내가 권한을 모두 가지고 있는 홈 폴더에 설치해야 하는데 이 방법을 적는다.</p>

<p>내 홈폴더에 설치하는 과정은 밑에 두 가지 나눌 수 있다.</p>

<ol>
  <li>
    <p>configure 파일을 이용해서 설치할 경로를 지정해주는 것</p>
  </li>
  <li>
    <p>bash_profile 파일을 수정해서 명령어를 사용할 수 있도록 해주는 것</p>
  </li>
</ol>

<p>대부분의 패키지는 다운 받고 압축을 풀면 configure 라는 파일이 있고 이 파일을 이용해서 설치에 대한 다양한 옵션을 설정해줄 수 있다. 예를 들어 설치할 패키지 폴더에서</p>

<pre><code>./configure --prefix=/home/USERNAME/PACKAGE_NAME
make &amp;&amp; make install
</code></pre>

<p>을 실행하면 1번 과정을 완료한 것이다. 위에 입력한 경로에 가보면 설치되어 있는 패키지를 확인할 수 있다. 하지만 이렇게 설치를 해도 아직 명령어를 사용할 수 없는 상태이다. 예를 들어 파이썬을 설치하는 중이라면</p>

<pre><code>python setup.py
</code></pre>

<p>이라는 명령어를 실행시켰을 때</p>

<pre><code>bash: python: command not found
</code></pre>

<p>이라는 에러 메시지를 만나게 된다는 뜻이다. 아직 리눅스는 이 명령어를 어떻게 실행시키는지 모르는 상태이고 우리는 리눅스에게 ‘이 명령어를 치면 어느 경로를 참조해야 하는지’를 알려줘야한다. 그래서 우리는 ~/.bash_profile 를 수정한다. 단순히 .bash_profile 마지막 줄에</p>

<pre><code>PATH=$PATH:$HOME/PACKAGE_NAME/bin
</code></pre>

<p>을 추가하는 일로 끝나는 데 막상 이렇게 수정한 후에 명령어를 다시 입력해봐도 똑같은 에러 메시지를 만날 수 있다. 그 이유는 .bash_profile은 쉘이 시작될 때만 읽히기 때문인데 이를 위해서 우리는 .bash_profile을 다시 읽어와야 한다.</p>

<pre><code>source ~/.bash_profile
</code></pre>

<p>이라는 명령어로 .bash_profile을 다시 읽어올 수 있고 이제 명령어를 사용해보면 정상적으로 실행됨을 알 수 있다.</p>


	</section>
</article>


    <article class="post">
	
	<header class="post-header">
		<span class="post-meta">22 Apr 2014</span>
		<h2 class="post-title">
			
			<a href="/blog/2014/04/22/a-sample-post/">
			
				This Is a Sample Post</a>
		</h2>
	</header>
	<section class="post-excerpt">
		<p>Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</p>


	</section>
</article>

<nav class="pagination" role="pagination">
    
    <span class="page-number">Page 1 of 1</span>
    
</nav>
  </main>
  <footer class="site-footer"><a class="subscribe icon-feed" href="http://hjinu.github.io/atom.xml"><span class="tooltip">Subscribe!</span></a>


<div class="inner">









<section class="copyright">All content copyright <a href="/">hjinu</a> © 2014 • All rights reserved.</section>

<section class="poweredby">Casper theme by <a class="icon-ghost" href="http://tryghost.org">Ghost</a> &amp; Published with <a href="http://octopress.org">Octopress</a></section>

</div>
</footer>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js"></script>
<script src="//yandex.st/highlightjs/7.3/highlight.min.js"></script>  
<script>hljs.initHighlightingOnLoad()</script>


<script type="text/javascript">
      var disqus_shortname = 'hjinu';
      
        
        var disqus_script = 'count.js';
      
    (function () {
      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>




</body>
</html>
